# ZZY的ACM-ICPC竞赛学习记录

这是我的一个算法竞赛学习笔记，用于记录学习算法时的各类知识点，以及方便日后整理自己的板子~



## C++小技巧

这里一般存一些可以解决类似初始化等一系列基础问题，避免在此问题上多花时间。

1. 无穷大：

​	**inf** : infinity 无穷大的数，一般是超过浮点数的表示范围。

​	赋值时若需要无穷大的数，可以这样：

```c++
const int INF = 0x3f3f3f3f;//当然需要先定义
int ans = INF;
```

2. cin有返回值，读到返回1，没读到返回0，于是当遇见不知道有多少输入时可以这样输入：

```c++
while(cin >> A >> B){
	...
}
```

而`scanf`不一样，`scanf`全部读到会返回读的个数例如`scanf("%d%d%d",&a&b&c);`会返回3，而只读到2个数或1个数会返回EOF(End Of File)，这个数应该为-1，于是判断`scanf`是否读完，就判断是 否为-1即可。



## C++的STL相关

函数：求下一个排列：`next_permutation(a,a+n) //写法与sort类似`

sort：

![image-20230709222251730](https://cdn.jsdelivr.net/gh/Zeratuli/Image@main/img/202401191809346.png)

### 容器类

![image-20230709225658901](https://cdn.jsdelivr.net/gh/Zeratuli/Image@main/img/202401191809347.png)

#### vector

vector是个动态数组，可以改变长度。

vector不能直接赋值，需要其他元素辅助赋值，比如：

```c++
int num;
vector<int> v1;
cin >> num;
v1.push_back(num);
```

#### stack与queue

![image-20230711202837382](https://cdn.jsdelivr.net/gh/Zeratuli/Image@main/img/202401191809348.png)

![image-20230711202902180](https://cdn.jsdelivr.net/gh/Zeratuli/Image@main/img/202401191809349.png)

```C++
//stack栈
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e6+100;
const int mod = 1e9+7;
signed main(void){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	stack<int> st;
	st.push(1);//不存在前插和后插，所以没有back和front。
	st.push(1);
	st.push(2);
	cout << st.top() << endl;//输出为2
	cout << st.size() << endl;//输出为3
	cout << st.empty() << endl;//有元素，输出为0(false),否则为1(true)
	return 0;
}
```



```C++
//queue队列
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int N = 1e6+100;
const int mod = 1e9+7;

signed main(void){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	queue<int> qu;
	int n;
	cin >> n;
	cout << n << " " <<  n+1 << " " << n+2 << endl; 
	qu.push(n);//向队尾插入元素
	qu.push(n+1);
	qu.push(n+2);
	cout << qu.front() << endl; //队首元素
	cout << qu.back() << endl; //队尾元素
	qu.pop();//弹出队首元素
	cout << qu.front() << endl; //队首元素
	cout << qu.back() << endl; //队尾元素
	return 0;
}

```



#### map

![image-20230711230244324](https://cdn.jsdelivr.net/gh/Zeratuli/Image@main/img/202401191809350.png)

map是通过红黑树（类平衡二叉树）实现的，插入删除查找等操作的复杂度都为$O(logn)$,因此很方便

##### map需要引入map包：

`#include <map>`

##### map的定义：

`map<key,value> mp`（之后展示都以mp为变量名称）

map包含两个内容：第一个为键，第二个为值，键用来存储物品的名称，值用来存储物品的内容。

可以写成：

`map<int,int>mp`,`map<string,int>`,`map<ty,int>`（ty为结构体类型）

##### map的使用：

插入，访问，查找，清空，删除，交换，判断是否为空

###### 插入：一般用insert()

这里用`map<int,int> mp`举例：

- 可以用pair，pair需要调用utility库：`#include <utility>`
  使用方法：`mp.insert<pair<int,int>(0,1)>`;



##### unorded_map

是一种用哈希表实现的一种<键,值>的实现方式，因此有哈希表易于查找的特性，但是由于失去了有序性，故顺序相关问题就相形见绌了。

![image-20231126163734326](https://cdn.jsdelivr.net/gh/Zeratuli/Image@main/img/202401191809351.png)

调用API：

```c++
unorded_map<string, int> ump;//定义一个unordered_map类型变量，取名为ump

ump.insert(make_pair("test",3));//给ump增加一个<键，值>对，为<test,3>
ump.emplace("test",3);//同理，但是更简短

unordered_map<string,int>::iterator it;//定义一个同类的迭代器,用以对元素进行操作
it = ump.begin();//改迭代器位置
cout << it->first << " " << it->second << endl;//打印键对应的值
for(it; it != ump.end(); it++){
	cout << it->first << " " << it->second << endl;//遍历
}

//根据键删除,如果没找到则n=0
size_t n = ump.erase("test")   //删除,这里size_t换成int(long long)对于竞赛而言是大致一样的

auto it = ump.find("test") //通过查找操作来精确修改值
if(it != umap.end()) 
    it->second = new_value; 

//map中查找x是否存在
ump.find(x) != map.end()//查的两种方式
ump.count(x) != 0
```





#### set去重自动排序

set是一个集合，遇见重复的可以去掉，自动用类似红黑树的方式进行排序（简化排序的方法诞生了），复杂度很低，插入，删除，查找都为$O(logn)$

##### 使用方法

```C++
int n = 1;
set<int> st;
st.insert(n); //插入
st.erase(n);//擦除
st.find(n);//查找对应数值
set<int>::iterator it;//用迭代器it进行遍历
for(it = st.begin(); it != st.end(); it++){
    cout << *it << endl;
}
```

set可以用迭代器进行数据的精确查找，如下：

```c++
st.insert(a);	
	st.insert(b);
	int temp = k;
	set<int>::iterator it = st.begin();
	while(temp--){
		st.insert(*it + a);
		st.insert(*it + b);	
		it++;
	}
	it = st.begin();
    advance(it, k-1);
    cout << *it << endl;	
```

set需要查找最后一位元素的前一位时：

```C++
set<int>::iterator it;
it = st.begin();
it--;
```

##### 相关例题

###### 指纹锁

```tex
时间限制：C/C++ 1秒，其他语言2秒
空间限制：C/C++ 262144K，其他语言524288K
64bit IO Format: %lld
```

题目描述              

```tex
 HA实验有一套非常严密的安全保障体系，在HA实验基地的大门，有一个指纹锁。 
该指纹锁的加密算法会把一个指纹转化为一个不超过1e7的数字，两个指纹数值之差越小，就说明两个指纹越相似，当两个指纹的数值差≤k时，这两个指纹的持有者会被系统判定为同一个人。
现在有3种操作，共m个，
 操作1：add x，表示为指纹锁录入一个指纹，该指纹对应的数字为x，如果系统内有一个与x相差≤k的指纹，则系统会忽略这次添加操作
 操作2：del x，表示删除指纹锁中的指纹x，若指纹锁中多个与x相差≤k的指纹，则全部删除，若指纹锁中没有指纹x，则可以忽略该操作，
 操作3：query x，表示有一个持有指纹x的人试图打开指纹锁，你需要设计一个判断程序，返回该人是否可以打开指纹锁（只要x与存入的任何一个指纹相差≤k即可打开锁）。
   初始状态，指纹锁中没有任何指纹。
```

输入描述:

```
第一行有2个正整数m，k。
接下来m行，每行描述一种操作：add x，del x或query x。
```

输出描述:

```
对于每个query操作，输出一行，包含一个单词“Yes”或“No”，表示该人是否可以打开指纹锁。
```

示例1

输入

```
4 3
add 1
add 10
query 5
query 4
```

输出

```
No
Yes
```

示例2                        

输入

```
4 3
add 1
query 4
del 1
query 4
```

输出

```
Yes
No
```

示例3                        

输入

```
6 3
add 10
query 10
add 5 
query 5
del 7		//系统将指纹10和指纹5全部删除
query 8
```

输出

```
Yes
Yes
No
```

备注:

```
对于100%的测试数据：
1 ≤ k,m ≤ 1000000
数据量较大，注意使用更快的输入输出方式。
```

样例代码：

```C++
#include <bits/stdc++.h>
#define int long long
using namespace std;

int k = 0;

struct node{
	int num;
	bool operator <(const node &b)const{
		if(abs(this->num - b.num) <= k) return false;
		else return this->num < b.num;
	}
};

signed main(void){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);cout.tie(nullptr);

	set<node> st;
	int m;
	cin >> m >> k;
	for(int i = 0; i < m; i++)
	{
		
		char a[10];
		int n;
		cin >> a >> n;
		node now;
		now.num = n;
		if(a[0] == 'a') st.insert(now);
		else if(a[0] == 'd') st.erase(now);
		else{
			if(st.find(now) != st.end()){
	   			cout << "Yes" << endl;
			}
			else
				cout << "No" << endl;
		}
	}

	return 0;
}

```

#### multiset

multiset是set的保留重复的模式，set是集合，那么multiset就是可重复集合，这样即可以按照顺序排序又可以不让数字被合并，可以使用lower_bound()函数与upper_bound()函数记录数量，很方便。

所有的stl都可以存储结构体格式，但如果需要排序，则需要修改一下排序规则。

调用API：

```c++
multiset<int> mst;//创建/初始化一个multiset变量，类型为int
mst.insert();//向mst中插入元素
mst.erase();//擦除erase中的元素。
multiset<int>::iterator it;//创建一个multiset的int类型的迭代器it
it = mst.lower_bound(p);//返回第一个大于等于p位置的数
it = mst.upper_bound(p);//返回第一个小于等于p位置的数
```

相关例题：UVA：

题面：

```tex
The princess of Centauri Prime is the galaxy’s most eligible bachelorette of the year. She has hopeful
 grooms lined up in front of the royal palace for a chance to spend 5 minutes to try and impress her.
 After 5 minutes, the gentleman is carried out of the royal chambers by the palace guards, and the
 princess makes a decision. She rates the lad on his lineage and charm by giving him a score for each of
 the two properties. On Centauri Prime, low scores are better than high scores.
 Suppose that she observes two gentlemen - A and B. She assigns A the scores LA and CA (for
 lineage and charm, respectively). B receives scores LB and CB. Then A is dominated by B if either
 • LB < LA and CB ≤ CA, or
 • LB ≤ LA and CB < CA.
 In other words, if at least one of B’s scores is better than A’s, and the other score is not worse. She
 considers a gentleman to be efficient (or Pareto-optimal) if she has not yet met any other gentleman who
 dominates him. She maintains a list of efficient grooms and updates it after each 5-minute presentation.
 Given the queue of bachelors and the scores assigned to them by the princess, determine the number
 of entries in the list of efficient grooms after each performance.
```

输入描述:

```tex
The first line of input gives the number of cases, N (0 < N < 40). N test cases follow.
Each one starts with a line containing n (0 ≤ n ≤ 15000) — the size of the queue. The next n lines
will each contain two scores (integers in the range [0, 10^9]). Initially, the list is empty.
```

输出描述：

```tex
For each test case, output one line containing ‘Case #x:’ followed by n lines, line i containing the size
of the list of efficient grooms after the i-th update. Print an empty line between test cases.
```

题目翻译：

```tex
n个人，每个人有两个属性x，y，若对于每一个数p，不存在一个点q，使得p.x >= q.x, p.y > q.y 或者 p.x > q.x, p.y >= q.y，那么说这个人是有优势的
现在动态插入数，请问每次插入后有优势的数有几个？
输入输出格式如下
```

示例：

输入

```tex
4
1
100 200
2
100 200
101 202
2
100 200
200 100
5
11 20
20 10
20 10
100 20
1 1
```

输出

```tex
Case #1:
1

Case #2:
1
1

Case #3:
1
2

Case #4:
1
2
3
3
1
```

AC代码：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int N = 1e5+100;
const int mod = 1e9+7;
const int INF = 0x3f3f3f3f;

struct troop1{
	int x,y;
	bool operator < (const troop1 &a)const{
		return x > a.x || (x == a.x && y < a.y);
	}//将攻击力排序
}p[N];
struct troop2{
	int x,y;
	bool operator < (const troop2 &a)const{
		return y > a.y || (y == a.y && x < a.x);
	}//将防御力排序
}q[N];

multiset<int> mst;

void solve(){
	int n,m;
	cin >> n >> m;
	for(int i = 0; i < n; i++)
		cin >> p[i].x >> p[i].y;
	for(int i = 0; i < m; i++)
		cin >> q[i].x >> q[i].y;
	if(n < m){
		cout << -1;	
		return ;
	}
	sort(p,p+n);//防御力排序,一会先消灭防御高的
	sort(q,q+m);//攻击力排序,找够格的防御力最低的那个。
	int ans = n;
	int j = 0;
	for(int i = 0; i < m; i++){
		int attack = q[i].x;
		int defence = q[i].y;
		while(j < n && p[j].x >= defence){
			mst.insert(p[j].y);
			j++;
		}
		if(mst.empty()){
			cout << -1;
			return ;
		}
		multiset<int>::iterator it = mst.upper_bound(attack);//找到能抵御攻击的最小的那一个
		if(it == mst.end()){//没找到就拿防御力最小的充数
			it = mst.begin();
			ans--;
		}
		mst.erase(it);
	}
	mst.clear();
	cout << ans;

	return ;
}

signed main(void){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	int t = 1;
	cin >> t;
	for(int i = 1; i <= t; i++){
		cout << "Case #" << i << ": ";
		solve();
		cout << endl;
	}

	return 0;
}
```



#### bitset01串

一种通过存储0和1的方式存储数据的一种数据结构，可以在输入的数据量的基础上内存缩减32倍（➗32），有效地防止了内存溢出，压缩了空间

```

```



####  deque双端队列

deque是STL的双端队列的实现方式，主要方式为动态分配存储空间，并以常数项时间复杂度控制队头队尾的插入删除，具有很好的使用效果。

##### deque的常用API：

```C++
deque<int> dq;//创建一个deque双端队列
dq.push_back(5);  //在双端队列末尾插入5这个元素
dq.push_front(6); //在双端队列队头插入6这个元素
dq.empty();//判断双端队列是否为空
dq.size();//输出双端队列的大小
dq.resize(num);//重新规定双端队列的长度为num，若之前比num长则舍去后面超出的，若比num短则加上初始化的内容
deque<int>::iterator it;//定义一个it指针，输出值用*it。
```

deque使用示例：

```C++
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int N = 1e6+100;
const int mod = 1e9+7;

signed main(void){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int num = 5;
	deque<int> dq;//创建一个deque双端队列
	dq.push_back(5);  //在双端队列末尾插入5这个元素
	dq.push_front(6); //在双端队列队头插入6这个元素
	cout << dq.empty() << endl;//判断双端队列是否为空
	int len = dq.size();//输出双端队列的大小
	cout << len << endl;
	//back为5，front为6
	cout << dq.back() << endl;
	cout << dq.front() << endl;
	dq.resize(num);//重新规定双端队列的长度为num，若之前比num长则舍去后面超出的，若比num短则加上初始化的内容
	//num=1,下面的back和front都为6,num=5,back为0，front为6
	cout << dq.back() << endl;
	cout << dq.front() << endl;
	//int q = dq.insert(1,8);//插入值8
	deque<int>::iterator it;
	for(it = dq.begin(); it != dq.end(); it++)//遍历操作
		cout << *it << " ";
	cout << endl;
	return 0;
}
```



#### priority_queue优先队列

##### 基本API：

```c++
priority_queue<int> pq; //初始化一个叫做pq的优先队列
priority_queue<int,vector<int>,greater<int>> pq;//pq是优先最大值在前面的，greater是指把大的排后面，因此是相反的，用less就是基本的，优先队列还可以存结构体，但需要重新对排序规则进行定义。
pq.push(s);//放入元素s
pq.pop();//弹出堆顶元素
pq.top();//取堆顶元素的值
```

参考：[优先队列](C:\Users\54219\Desktop\ACM-ICPC\板子\板子（自创）\优先队列.md)

主要解决问题：

- 持续找最大/最小值的问题；

- topK问题：从海量数据中寻找最大的前k个数据，比如从1亿个数据中，寻找最大的1万个数。



## 一些头文件下的函数

1. cmath

|   函数   |       作用        |
| :------: | :---------------: |
| abs(a-b) | 输出绝对值\|a-b\| |
|          |                   |
|          |                   |
|          |                   |
|          |                   |
|          |                   |
|          |                   |
|          |                   |
|          |                   |

2. cstring/string.h

|           函数           |                             作用                             |
| :----------------------: | :----------------------------------------------------------: |
| `memset(a,0,sizeof (a))` | 为了防止数组中没有东西，给数组赋值用的，右边的a为int类型，通常用的赋值为0，-1，其他都不行。 |
|        ceil(1.1)         |      取不小于1.1的最大整数（就是2）（向正无穷方向取整）      |
|        floor(1.1)        |                     向负无穷大的方向取整                     |
|          round           |                         四舍五入取整                         |
|           rem            |                        求整数x/y余数                         |
|           fix            |                        向0的方向取整                         |
|        max(math)         |                  求math的最大值（min同理）                   |
|        sum(math)         |                           求和函数                           |
|                          |                                                              |

3. algorithm

|            函数            |                             作用                             |
| :------------------------: | :----------------------------------------------------------: |
| sort(a,a+3,greater<int>()) | 排序（第三个逗号可以不用写，默认为排最小值，这个为快速排序），第三个逗号内容为排从a到a+3的从大到小的值 |
|         __gcd(a,b)         |  找出a,b的最大公约数，a/__gcd(a,b)就是a除去a与b的最大公约数  |
|                            |                                                              |
|                            |                                                              |
|                            |                                                              |
|                            |                                                              |
|                            |                                                              |
|                            |                                                              |
|                            |                                                              |

4. cstdlib

|  函数  |     作用      |
| :----: | :-----------: |
| system | 可以引DOS指令 |
|        |               |
|        |               |
|        |               |
|        |               |
|        |               |
|        |               |
|        |               |
|        |               |

5. string

   ![image-20230707112015550](https://cdn.jsdelivr.net/gh/Zeratuli/Image@main/img/202401191809352.png)

long long最大值：2^63^-1 unsigned long long最大值：2^64^-1

## 模板

### 枚举

#### 二进制枚举

二进制枚举是通过二进制0与1表示是否选这个数上的数的一种方式，0就不选，1就选，从而达到对一个数进行处理

枚举范围：

```c++
for(int i=0;i<(1<<n);i++)
```

内层判断：

```c++
for(int j=0;j<n;j++)//逐个位去判断
   if(a & 1<<j)//若为1则选，否则不选。
```

经典例题：

小红拿到了两个正整数a和b，她每次操作可以选择其中一个正整数，删除一个数位。例如，对于"1243"而言，进行一次操作可以生成"124"、"123"、"143"或"243"。
 小红希望最终a是b的倍数或者b是a的倍数。她想知道自己最少的**操作次数**是多少？

输入：

```tex
37 111
```

输出：

```tex
0//37可把111整除，37|111
```

AC代码:

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int N = 1e6+100;
const int mod = 1e9+7;
const int INF = 0x3f3f3f3f;

void solve(){
    int a,b;
    cin >> a >> b;//输入数据
    string A = to_string(a), B = to_string(b);//将数字转化成字符串，方便按位运算取值
    int len1 = A.length(), len2 = B.length();
    int ans = INF;//定义一个无穷大值
    for(int i = 1; i < (1<<len1); i++){//(1<<len1)把所有可能出现的情况暴力枚举出来
        int x = 0;//这里是我们需要计算的新数的值
        for(int j = 0; j < len1; j++) if(1&(i>>j)) x = x*10 + (A[j]-'0');//按照01判断是否取A的某一位
        for(int j = 1; j < (1<<len2); j++){
            int y = 0;
            for(int k = 0; k < len2; k++){
                if(1&(j>>k)) y = y*10 + (B[k]-'0');//同A，取B的值
            }
            if(x==0||y==0)//若x或y为0则说明没进循环or那个数为0，防止mod0而进行判断
                ans=min(ans,len1-(int)__builtin_popcountll(i)+len2-__builtin_popcountll(j));
            else if(x%y==0 || y%x==0) //对变换后的数判断是否能被整除
                ans=min(ans,len1-(int)__builtin_popcountll(i)+len2-__builtin_popcountll(j));
                //__builtin_popcountll 是一个计算数中有多少个1的函数
        }
    }
    ans = (ans==INF)?-1:ans;//用一个三目运算符判断ans值
    cout << ans << endl;

    return ;
}

signed main(void){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t = 1;
    while(t--){
        solve();
    }

    return 0;
}
```



### 高精度

#### 高精度加法

```C++
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int SIZE = 9999;
signed main(void){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);cout.tie(nullptr);
	
	string A,B;
	cin >> A >> B;
	int len1 = A.length();
	int len2 = B.length();
	int a[SIZE],b[SIZE];
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	for(int i = 0; i < len1; i++){
//		cout << A[i];
		a[i] = A[len1-i-1] - '0';
	}
	for(int i = 0; i < len2; i++){
	 	b[i] = B[len2-i-1] - '0';
	}
	int c[SIZE];
	memset(c,0,sizeof(c));
	int d = max(len1,len2);
	for(int i = 0; i < d; i++){
		c[i] = c[i]+a[i]+b[i];
		if(c[i] >= 10){
			c[i+1] = c[i]/10;
			c[i] %= 10;
		}
	}
	if(c[d+1])
		d++;
	for(int i = d; i >= 0; i--){
		cout << c[i];
	}
	return 0;
}

```

#### 高精度减法

```C++
#include <bits/stdc++.h>
#define int long long
using namespace std;

bool cmp(string A,string B){
	int len1 = A.length();
	int len2 = B.length();
	if(len1 > len2) return 1;
	if(len1 < len2) return 0;
	if(A>B) return 1;
	return 0;
}

signed main(void){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);cout.tie(nullptr);

    string A,B;
    cin >> A >> B;
    
	int len1 = A.length();
	int len2 = B.length();
	int a[len1+1000],b[len2+1000];

	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
    for(int i = 0; i < len1; i++)
		a[i] = A[len1-1-i] - '0';
	for(int i = 0; i < len2; i++)
		b[i] = B[len2-1-i] - '0';
	int len = max(len1,len2);
	int c[len+100];
	memset(c,0,sizeof(c));
	if(cmp(A,B)){
		for(int i = 0; i < len; i++){
			c[i] += a[i]-b[i];
//			cout << c[i] << endl;
			if(c[i] < 0){
				c[i] = 10 + c[i];
				c[i+1]--;
			}
		}
	}
	else{
		for(int i = 0; i < len; i++){
			c[i] += b[i]-a[i];
			if(c[i] < 0){
				c[i] = 10 + c[i];
				c[i+1]--;
			}
		}
	}
	while(!c[len])
		len--;

	if(!cmp(A,B))
		cout << "-";
	for(int i = len; i >= 0; i--){
		cout << c[i];
	}
	return 0;
}
```

#### 高精度乘法

```C++
#include <bits/stdc++.h>

using namespace std;

const int SIZE = 15000;

int main(void)
{
	int a[SIZE],b[SIZE],c[SIZE];
	string A, B;
	cin >> A >> B;
	int lena = A.length();
	int lenb = B.length();
	for(int i = lena - 1; i >= 0; i--){
		a[lena-i] = A[i] - '0';
	}
	for(int i = lenb - 1; i >= 0; i--){
		b[lenb-i] = B[i] - '0';
	}
	memset(c,0,sizeof c);
	int len = lena + lenb;
	for(int i = 1 ; i <= lena; i++){
		for(int j = 1; j <= lenb; j++){
			c[j+i-1] += a[i]*b[j];
//			cout << c[j+i-1] << endl;
		}
	}
	for(int i = 1; i <= lena + lenb; i++)
	{
		c[i+1] += c[i]/10;
		c[i] %= 10;
	}
	for(int i = len; i > 0; i--)
//		cout << c[i];
//	cout << endl;
    while(c[len]==0&&len>1)
		len--;
	for(int i = len; i > 0; i--)
		cout << c[i];
    
	return 0;
}
```

#### 高精度除法

##### 高精度除以低精度

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;

void divide(string A,int b){
	int len = A.length();
	int len1 = len;
	int c[len+10];
	memset(c,0,sizeof(c));
	int d = 0;
	for(int i = 0; i < len; i++){
		d = d*10 + A[i]-'0';
		c[len-1-i] = d/b;
		d = d%b;
	}
	while(!c[len])
		len--;
	for(int i = len; i >= 0; i--){
		cout << c[i];
	cout << endl;
 	cout << d << endl;
	}
}

signed main(void){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);cout.tie(nullptr);

	string A;
	int b;
	int len = A.length();
	int a[len+100];
	cin >> A >> b;
	divide(A,b);
    
	return 0;
}

```

##### 高精度除以高精度



### 质数（素数）筛

利用数的倍数关系不是质数这一条件简化运算，达到优化算法的目的

算法复杂度是：$$O(nloglogn)$$

题目描述                    

  输入一个自然数N，按质数定义从小到大输出1~N（包含N）中所有的质数 

输入描述:

```
输入一行，包含一个整数N

1 <= N <= 2000
```

输出描述:

```
输出一行，包含所有的质数，按照从小到大的顺序输出，以空格隔开。
```

​            

输入

```
20
```

输出

```
2 3 5 7 11 13 17 19
```



代码：

```c++
#include <bits/stdc++.h>

using namespace std;

int main(void){
	int n;
	int prime[3000];
	
	cin >> n;
	
	for(int i = 2; i <= n; i++)
	{
		if(prime[i] == 0){
			printf("%d ",i);
			for(int j = i+i; j < n; j+=i)
			{
				prime[j] = 1;
			}
		}
	}
	
	return 0;	
}
```



### 模拟，枚举与贪心

#### 前缀和与差分

指利用角标表示需要长度的数组的头和尾，头赋值为1，尾赋值为-1，取一个新的a并初始化为0，让a加上数组的每一项，当加到头时为1，加到尾时为0，这样就方便计算数据了（前缀和），还可以将重复的区间合并。

差分是离散数学中的一个概念，这里指对一串数据同时改变相同大小的值，以方便计算，比如6 7 5 7 6 5 6 7 可以-6改为0 1 -1 1 0 -1 1



例题：

##### [NOIP2005]校门外的树

某校大门外长度为L的马路上有一排树，每两棵相邻的树之间的间隔都是1米。我们可以把马路看成一个数轴，马路的一端在数轴0的位置，另一端在L的位置；数轴上的每个整数点，即0，1，2，……，L，都种有一棵树。  

  由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。  

输入描述:																

```
第一行有两个整数：L（1 <= L <= 10000）和 M（1 <= M <= 100），L代表马路的长度，M代表区域的数目，L和M之间用一个空格隔开。接下来的M行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标。
```

输出描述:

```
包括一行，这一行只包含一个整数，表示马路上剩余的树的数目。                 
```

输入

```
500 3
150 300
100 200
470 471
```

输出

```
298
```

代码：

```c++
#include <bits/stdc++.h>

using namespace std;

struct ty
{
	int gen;
	int tal;
}a[1000];

bool comp(ty a,ty b){
	if(a.tal == b.tal) return a.gen < b.gen;
	return a.tal < b.tal;
}

int main(void)
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int l,m;
	cin >> l >> m;
	for(int i = 1; i <= m; i++)
	{
		int x, y;
		cin >> x >> y;
		a[i].tal = x;
		a[i+m].tal = y+1;
		a[i].gen = 1;
		a[i+m].gen = -1;
	}
	sort(a+1,a+1+2*m,comp);//按顺序排好，方便+1-1 
	int cnt = 0;
	int b = 0;
	
	for(int i = 1; i <= 2*m; i++)
	{
		b += a[i].gen;
		if(b == 1 && a[i].gen == 1){
			cnt += a[i].tal - a[i-1].tal;
			cout << a[i-1].tal << endl;
		}
	}
	cnt += l - a[2*m].tal + 1;
	cout << cnt;
	
	
	return 0;
}
```



#### Two Pointer 双指针/尺取法/追逐法

利用一前一后两个方向的位置，对数据进行处理，比如：

- 计算一串数据中子串和，求最少的符合要求的子串和
- 计算一串数据中字串和，求最多符合要求的字串和

例题：

##### 求连续字串和的最小值

给定长度为n的正整数数列以及正整数S，求出总和不小于S的连续子串的长度的最小值，如果解不存在，输出0。数列不小于10^5^

模板代码：

```c++
#include <iostream>//输入输出需要，也可以用c++
#include <cmath>//min需要
#include <cstring>//memset需要

using namespace std;

int t,n,s;
int a[100000];//开够题目所需空间

int main(void)
{
	scanf("%d",&t);
	while(t--)//0为false，当t减为0时停止循环
	{
		scanf("%d%d",&n,&s);
		memset(a,0,sizeof(a));
        //初始化a，避免上一次数据影响下一次数据
		for(int i = 1; i <= n; i++){
			scanf("%d",&a[i]);//录入数据
		}
		int len = n+1;
        //取n+1是为确保len开始时一定比原长度大，便于后续判断
		int sum = 0, r = 0;
        //注意这里sum与r在这里初始化也是为了保证不会被上一次数据影响到
		for(int l = 1; l <= n; l++){
            //把数据长度开始拉长和缩短
			while(r <= n && sum < s){
				r++;//尾变化
				sum += a[r];//开始对sum加值看是否>s
			}
			if(sum >= s)
			{
				len = min(len,r-l+1);
                //在len与区间长度中找最小值
			}
			sum -= a[l];//把末尾的框外的数据清除
		}
		if(len > n) printf("0\n");
        //若没有符合条件的内容输出0
		else printf("%d\n",len);
	}
	return 0;
}
```



##### 字符串

小N现在有一个字符串S。他把这这个字符串的所有子串都挑了出来。一个S的子串T是合法的，当且仅当T中包含了所有的小写字母。小N希望知道所有的合法的S的子串中，长度最短是多少。

输入描述:

```tex
一行一个字符串S。只包含小写字母。S的长度不超过106.
```

输出描述:

```tex
一行一个数字，代表最短长度。数据保证存在一个合法的S的子串。
```

输入
```tex
ykjygvedtysvyymzfizzwkjamefxjnrnphqwnfhrnbhwjhqcgqnplodeestu
```

输出
```tex
49
```

模板代码：

```c++
#include<bits/stdc++.h>

using namespace std;

int jud[1000];//存下26个字母的ascii码
char s[1100000];//存下需要存储的数据
int ans= 10000000;//便于赋值取值

signed main()
{
    memset(jud,0,sizeof(jud));//给jud初始化
    cin>>s;
    int cnt=0,j=0;
    for(int i=0;i<strlen(s);i++)//根据字符串s的大小决定i的值
    {
        if(jud[s[i]]==0&&cnt<26)
        //反向划值，根据有边界不是所要的值来确定，这样当达到26个数时代表每一个字母都有被存进去
        {
                cnt++;
        }
        jud[s[i]]++;//所在的那个字母位置+1
        while(jud[s[j]]>1)
        //若多出来，则首先减去这个位置的值并且末尾的指针跟上前进一位，确保了内部始终保持接近26个字母的长度
        {
            jud[s[j]]--;
            j++;
        }
        if(cnt==26)//在达成目标26个字母后，开始给答案赋值
        {
            ans=min(ans,i-j+1);//取值
        }
    }
    cout<<ans;
            return 0;
}
```

### 质数筛（欧拉筛）

```C++
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int maxn = 1e6+10000;
int primes[maxn];
bitset<maxn> prime;

void ola(int r){
	int cnt = 1;
	int r1 = r;
	for(int i = 2; i <= r1; i++){
		if(!prime[i]){
			primes[cnt++] = i;
		}
		for(int j = 1; primes[j]*i <= r1; j++){
			prime[primes[j]*i] = 1;
			if(i % primes[j] == 0)
				break;
		}
	}
	return ;
}

signed main(void){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);cout.tie(nullptr);
	prime[0] = prime[1] = 1;
	int T,l,r,ans;
	cin >> T;
	int k = 1e6+10;
	ola(k);
	while(T--){
		cin >> l >> r;

		ans = 0;
		for(int i = l; i <= r; i++){
			if(prime[i] == 0) ans++;	
		}
		cout << ans << endl;
	}
	return 0;
}

```

使用时只需要改变想取的素数范围就可以了。

### gcd辗转相除法求最大公因数（欧几里得算法）

用递归实现。

```C++
#include <bits/stdc++.h>
#define int long long
using namespace std;

int gcd(int a, int b){
	if(b == 0) return a;
	return gcd(b,a%b);
	return 0;	
}//key

signed main(void){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);cout.tie(nullptr);
	int n,m;
	cin >> n >> m;
	cout << gcd(n,m);

	return 0;
}

```

### 排序算法

需要掌握的排序算法一共有九种：

1. 时间复杂度为$$O(n^2)$$的排序算法：

- 冒泡排序
  基于数字大小对数组进行排序，一次对两个元素进行排序

- 选择排序
  每次选择最大的数进行排序，由大到小整理顺序

- 插入排序

  每次按顺序拿出一个数，插进现有的顺序中（每选一次进行一次排序

2. 三种不基于比较的排序：

- 桶排序
  提前把要排序的内容开好空间，每次填入一个数，所在的位置的下标++
- 基数排序
  每次找出个位，十位，百位的顺序的数字，并依次排序，然后按照最大位排出的顺序排序
- 计数排序
  每次将桶排序的内容进行一次前缀和

3. 归并排序和快速排序

   归并排序：把要排序的数组分成两半，一直分下去，直到不能分了为止。把左边一个和右边一个进行合并，小的（或大的）放左边，然后不断进行合并直到完成排序。由于所有二分复杂度是$$log_2n$$，合并复杂度是$$n$$，合在一起就是$$nlog_2n$$复杂度。

   代码：

   ```C++
   #include <bits/stdc++.h>
   #define int long long
   #define endl "\n"
   using namespace std;
   const int N = 1e6;
   int a[N], b[N];
   
   void hebin(int l, int mid, int r){
   	int p = l, q = mid+1;
   	for(int i = l; i <= r; i++){
   		if((q > r) || (p <= mid && a[p] <= a[q])){
   			b[i] = a[p++];			 
   		}		
   		else
   			b[i] = a[q++];
   	}
   	for(int i = l; i <= r; i++){
   		a[i] = b[i];	
   	}
   	return ;	
   }
   
   void mergesort(int l,int r){
   	if(l == r) return ;
   	int mid = (l+r)/2;
   	mergesort(l,mid);
   	mergesort(mid+1,r);
   	hebin(l,mid,r);
   	return ;
   }
   
   signed main(void){
   	ios::sync_with_stdio(false);
   	cin.tie(nullptr);cout.tie(nullptr);
   	int n;
   	cin >> n;
   	memset(a,0,sizeof(a));
   	memset(b,0,sizeof(b));
   	for(int i = 0; i < n; i++){
   		cin >> a[i]	;
   	}
   	mergesort(0,n-1);
   	for(int i = 0; i < n; i++){
   		cout << a[i] << " ";	
   	}
   	return 0;
   }
   ```

由此可以很快速的解决逆序问题



### 二分法

可以较快地得到排好序的数组中某一元素的位置，对于缩小区间很实用

找`>=x`的第一个位置：

片段：

```C++
while(l<=r){
	mid = (l+r)/2;
	if(a[mid] >= x) l = mid + 1;
	else r = mid - 1;
}
```

代码：

```C++
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e6+100;
const int mod = 1e9+7;
int a[N];
void solve(){
	int n;
	cin >> n;
	for(int i = 1; i <= n; i++)
		cin >> a[i];
	sort(a+1,a+n+1);
	int x;
	cin >> x;
	int l = 1,r = n;
	int mid;
	for(int i = 1; i <= n; i++){
		cout << a[i] << " ";
	}
	cout << endl;
	while(l<=r){
		mid = (l+r)/2;
		if(a[mid] >= x) l = mid+1;
		else r = mid-1;
		cout << "l " << l << " r:" << r << endl;
	}//这里可以找到>=x的第一个位置
	cout << a[r+1] << endl;
	return ;
}
signed main(void){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	int t;
	t = 1;
	while(t--){
		solve();
	}

	return 0;
}
```

输入输出：

![image-20231007184519986](https://cdn.jsdelivr.net/gh/Zeratuli/Image@main/img/202401191809353.png)

可以看到，左界先从第6个元素4开始，右界持续减小，10 ->3, 7->5, 5->3,最后锁定3后的元素4.

C++ STL的二分查找函数：

binary_search

lower_bound

upper_bound

使用：

```C++
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int N = 1e6+100;
const int mod = 1e9+7;
int a[N];

void solve(){
	int n;
	cin >> n;
	for(int i = 1; i <= n; i++)
		cin >> a[i];
	sort(a+1,a+n+1);
	int x;
	cin >> x;
	int l = 1,r = n;
	int mid;
	for(int i = 1; i <= n; i++){
		cout << a[i] << " ";
	}
	cout << endl;
	while(l<r){
		mid = (l+r)/2;
		if(a[mid] >= x) r = mid-1;
		else l = mid+1;
	//  cout << "l " << l << " r:" << r << endl;
	}//这里可以找到>=x的第一个位置
	cout << a[r+1] << endl;
	cout << binary_search(a+1,a+n+1,8)<< endl;//查找这个数是否存在
	cout << lower_bound(a+1,a+n+1,3)- &a[1] << endl;//返回符合条件的元素位置(找小于能插入位置的位置)
	cout << upper_bound(a+1,a+n+1,3)- &a[1] << endl;//返回符合条件的元素位置(找大于能插入位置的位置)
	for(int i = 1; i <= n+1; i++){	
		cout << a[i] << " ";
	}

	return ;
}


signed main(void){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int t;
	t = 1;
	while(t--){
		solve();
	}
	return 0;
}

```

输入输出：
![image-20231007190527633](https://cdn.jsdelivr.net/gh/Zeratuli/Image@main/img/202401191809354.png)

一般用于解决最大值最小与最小值zui'da



### 01分数规划

规则：

$$ans = Max(\frac{\sum_{i = 0}^{k}a_i}{\sum_{i = 0}^{k}b_i})$$

方法：对答案进行二分，以一个很大的数进行二分。

由于我们要求$$\frac{\sum_{i = 0}^{k}a_i}{\sum_{i = 0}^{k}b_i}$$的最大值，令其值为$$x$$,则：

$$\frac{\sum_{i = 0}^{k}a_i}{\sum_{i = 0}^{k}b_i} = x_{max}$$

变换一下：

$$\sum_{i = 0}^{k}a_i {\ge} x\sum_{i = 0}^{k}b_i$$

$$\sum_{i = 0}^{k}a_i - x\sum_{i = 0}^{k}b_i {\ge} 0$$

即：

$$\sum_{i = 0}^{k}(a_i - x*b_i) {\ge} 0$$

即求每一位的$$a_i - x*b_i$$，然后加起来，大于0即为答案

代码：

```C++
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int N = 1e6+100;
const int mod = 1e9+7;
int n,k;

struct ans1{
	int c,v;//c:cost开销,V:value价值。
	int s;
}ans[N];

bool comp(ans1 A, ans1 B){
	return A.s > B.s;
}

int judge(int mid){
	for(int i = 1; i <= n; i++){	
		ans[i].s = ans[i].v - mid*ans[i].c;
	}
	sort(ans+1,ans+1+n,comp);
	int ansc = 0,ansv = 0,anss = 0;
	for(int i = 1; i <= k; i++){
		anss += ans[i].s;
		ansc += ans[i].c;
		ansv += ans[i].v;
	}
	if(anss < 0) return -1;
	else return ansv/ansc;
}

void solve(){
	cin >> n >> k;
	for(int i = 1; i <= n ; i++)
		cin >> ans[i].c >> ans[i].v;
	int l = 0, r = 1e9;
	int ans = 0;
	while(l <= r){
		int mid = (l+r)>>1;
		int temp = judge(mid);
		if(temp == -1) r = mid-1;
		else{ 
			l = mid+1;
			ans = temp;
		}
	}
	cout << ans << endl;
	return ;
}
signed main(void){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	int t;
	cin >> t;
	while(t--){
		solve();
	}
	return 0;
}

```



### 并查集

并查集相当于是给定一个multiset可重复集合，然后为了方便找某一个值，把查找方式从从头到尾完全查找一遍变为像树一样找到各个节点，大大节省了时间。

主要有以下特性：

- 实现集合的查找与合并
- 用树来存储一个集合
- 主要操作为 按秩合并 与 路径压缩
- 若只有按秩合并或路径压缩，则并查集单次操作的复杂度为$O(logn)$
- 按秩合并+路径压缩 的并查集，复杂度为$O(\alpha n)$,其中$\alpha$是**一个Ackerman函数**的某个反函数，范围很大，函数值可以看作不大于4的数，此时并查集的操作是可以看作常数的。

合并操作：

写一个merge函数与find函数，可以这样写（都只需一行）：

```c++
int find(int x){
	return fa[x] == x ? x : find(fa[x]);//寻找x的父节点是谁，若不是自己就一直递归查找
}
void merge(int x, int y){
	fa[find(x)] = find(y);//fa为一个一维数组，用以记录x点的父亲是谁
}
```

例题：

#### 基础并查集

链接：https://ac.nowcoder.com/acm/contest/22904/1021
来源：牛客网

题目描述

DongDong每年过春节都要回到老家探亲，然而DongDong记性并不好，没法想起谁是谁的亲戚（定义:若A和B是亲戚，B和C是亲戚，那么A和C也是亲戚），她只好求助于会编程的你了。 

输入描述:

```
第一行给定n,m表示有n个人，m次操作
第二行给出n个字符串，表示n个人的名字分别是什么(如果出现多个人名字相同，则视为同一个人)（保证姓名是小写字符串）
接下来m行，每行输入一个数opt,两个字符串x,y
当opt=1时，表示x,y是亲戚
当opt=2时，表示询问x,y是否是亲戚，若是输出1，不是输出0
数据范围:1<=n,m<=20000，名字字符长度小等于10
```

输出描述:

```
对于每个2操作给予回答
```

示例:           

输入

```
4 4
chen lin yi cheng
2 chen lin
1 chen lin
1 yi lin
2 yi lin
```

输出

```
0
1
```

AC代码：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int N = 2e5+100;
const int mod = 1e9+7;
const int INF = 0x3f3f3f3f;

map<string,int> mp;
int fa[N];

int find(int x){
	return fa[x] == x ? x : find(fa[x]);
}

void merge(int x, int y){
	fa[find(x)] = find(y);
}

void solve(){
	int n,m;
	cin >> n >> m;
	string A;
	for(int i = 0; i < n; i++){
		cin >> A;
		fa[i] = i;
		mp[A] = i;
		A.clear();
	}
	for(int i = 0 ; i < m; i++){
		string s1,s2;
		int x;
		cin >> x >> s1 >> s2;
		if(x == 1) {
			merge(mp[s1],mp[s2]);
		}
		else{
			if(find(mp[s1])!=find(mp[s2])){
				cout << 0 << endl;
			}
			else{
				cout << 1 << endl;
			}
		}
	}
	return ;
}

signed main(void){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	int t = 1;
	//cin >> t;
	while(t--){
		solve();
	}

	return 0;
}
```

#### 并查集路径压缩的练习

经过上面这道简单例题的学习后，我们顺理成章地可以做出许多题，但一些题数据量比较大，通常不能成功AC，面对这样的题时，我们考虑使用路径压缩来解决问题。

例题：[加边的无向图](https://ac.nowcoder.com/acm/contest/22904/1025)

题目描述：

```tex
给你一个 n 个点，m 条边的无向图，求至少要在这个的基础上加多少条无向边使得任意两个点可达~  
```

输入描述:

```tex
第一行两个正整数 n 和 m 。
接下来的m行中，每行两个正整数 i 、 j ，表示点i与点j之间有一条无向道路。
```

输出描述:

```
输出一个整数，表示答案
```

示例1

输入

```
4 2
1 2
3 4
```

输出

```
1
```

备注:

```
对于100%的数据，有n,m<=100000。
```

此题很明显，数据为100000，不算大，于是我们可以先按照基础并查集的思路写一遍。题目无非就是想让没有连上边的点被记录一下，那么我们可以造一个头节点，除了第一个与他相连的节点不记录外，其余的头节点每次都记录一下，这样我们就可以完成对需要加边数量的统计了。

90%代码：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int N = 1e6;
int fa[N],head = 100001;

int find(int n){
	return n == fa[n] ? n : n = find(fa[n]);
}
int merge(int x,int y){
	return fa[find(y)] = find(fa[x]);
}
void solve(){
	fa[head] = head;
	int n,m;
	cin >> n >> m;
	int a,b;
	for(int i = 1; i <= n; i++){
		fa[i] = i;
	}
	for(int i = 1; i <= m; i++){
		cin >> a >> b;
		merge(a,b);
	}
	int ans = -1;
	for(int i = 1; i <= n; i++){
		if(find(fa[i]) != head){
			merge(head,i);
			ans++;
		}
	}
	cout << ans << endl;
	return ;
}

signed main(void){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	int t = 1;
	//cin >> t;
	while(t--){
		solve();
	}
	return 0;
}
```

很明显，当需要不断加边时，若m为100000，n也为100000，同时不连头节点只连连边时，只连1，2。即进行两次循环，需要循环300000次，可能会很大。90%TLE也证实了这一点。此时我们解决这个问题，需要用到路径压缩。

在find内，每当我们连一次边时，可以把原来不是父节点的节点变为直接连接父节点，这样压缩了路径，减少了递归层数，优化了时间复杂度，代码如下：

```c++
int find(int n){//寻找+路径压缩
	while(n != fa[n]){
		fa[n] = fa[fa[n]];
		n = fa[n];
	}
	return n;
}
```

将改后的代码放入90%的代码中，就可以成功AC了。

AC代码：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int N = 1e6+100;

int fa[N],head = 100001;

int find(int n){//寻找+路径压缩
	while(n != fa[n]){
		fa[n] = fa[fa[n]];
		n = fa[n];
	}
	return n;
}
int merge(int x,int y){
	return fa[find(y)] = find(fa[x]);
}

void solve(){
	fa[head] = head;
	int n,m;
	cin >> n >> m;
	int a,b;
	for(int i = 1; i <= n; i++){
		fa[i] = i;
	}
	for(int i = 1; i <= m; i++){
		cin >> a >> b;
		merge(a,b);
	}
	int ans = -1;
	for(int i = 1; i <= n; i++){
		if(find(fa[i]) != head){
			merge(head,i);
			ans++;
		}
	}
	cout << ans << endl;
	return ;
}

signed main(void){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	int t = 1;
	//cin >> t;
	while(t--){
		solve();
	}

	return 0;
}
```



#### 带权并查集

带权并查集要求每个节点都有一个自己的权值要进行调整，因此在每次并入数据时需要我们对权值进行更新。

题目：[P5092 [USACO04OPEN] Cube Stacking](https://www.luogu.com.cn/problem/P5092#submit)

![image-20231125191342131](https://cdn.jsdelivr.net/gh/Zeratuli/Image@main/img/202401191809355.png)

AC代码：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int N = 1e6+100;
const int mod = 1e9+7;
const int INF = 0x3f3f3f3f;

int fa[N];
int self[N];//自己的权值
int roofsize[N];//到父节点的距离

int find(int x){
	if(fa[x] != x){
		int temp = fa[x];
		fa[x] = find(fa[x]);
		roofsize[x] += roofsize[temp];//调整回路大小，这里调整的是非根节点的节点回路大小，只有非根节点才能进入这一步
	}
	return fa[x];
}

void merge(int x, int y){
	int a = find(x);//代表x的根
	int b = find(y);//代表y的根
	if(a != b){//a,b两根不相等，则把b的根接在x上
		fa[b] = a;
		//接下来是对权值进行调整
		roofsize[b] += self[a];//将y的根b加上x的根a自己的值，代表加的回路大小
		self[a] += self[b];//将子节点的权值加在新的父节点上
	}
	return ;
}

void solve(){
	int n;
	cin >> n;
	for(int i = 0; i < n; i++){
		fa[i] = i;
		roofsize[i] = 0;
		self[i] = 1;
	}
	for(int i = 0; i < n; i++){
		char A;
		cin >> A;
		int x,y;
		if(A == 'M'){
			cin >> x >> y;
			merge(x,y);
		}
		if(A == 'C'){
			cin >> x;
			int ans = (self[find(x)]-roofsize[x]-1);//自己父节点的权值-自己离父节点的距离-1==自己的权值
			cout << ans << endl;
		}

	}
	return ;
}

signed main(void){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int t = 1;
	//cin >> t;
	while(t--){
		solve();
	}
	return 0;
}
```

用图来理解：

<img src="https://cdn.jsdelivr.net/gh/Zeratuli/Image@main/img/202401191809357.png" alt="image-20231125192245092" style="zoom:30%;" />

<img src="https://cdn.jsdelivr.net/gh/Zeratuli/Image@main/img/202401191809358.png" alt="image-20231125192531404" style="zoom:30%;" />

<img src="https://cdn.jsdelivr.net/gh/Zeratuli/Image@main/img/202401191809359.png" alt="image-20231125192640792" style="zoom:30%;" />

<img src="https://cdn.jsdelivr.net/gh/Zeratuli/Image@main/img/202401191809360.png" alt="image-20231125193919847" style="zoom:30%;" />

<img src="https://cdn.jsdelivr.net/gh/Zeratuli/Image@main/img/202401191809361.png" alt="image-20231125194328171" style="zoom:30%;" />

#### 种类并查集

种类并查集，顾名思义就是把相同种类的放在一起，可以对撒谎问题（找错问题）进行解决。

典型例题：食物链

题目：



题目描述                    

  动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B，B吃C，C吃A。 

  现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。 

  有人用两种说法对这N个动物所构成的食物链关系进行描述： 

  第一种说法是“1 X Y”，表示X和Y是同类。 

  第二种说法是“2 X Y”，表示X吃Y。 

  此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 

  1） 当前的话与前面的某些真的话冲突，就是假话； 

  2） 当前的话中X或Y比N大，就是假话； 

  3） 当前的话表示X吃X，就是假话。 

  你的任务是根据给定的N（1≤N≤50,000）和K句话（0≤K≤100,000），输出假话的总数。 


输入描述:

```
第一行是两个整数N和K，以一个空格分隔。
以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。
若D=1，则表示X和Y是同类。
若D=2，则表示X吃Y。
```

输出描述:

```
只有一个整数，表示假话的数目。
```

示例1 

输入

```
100 7
1 101 1   
2 1 2     
2 2 3     
2 3 3     
1 1 3     
2 3 1     
1 5 5
```

输出

```
3
```

说明

![img](https://uploadfiles.nowcoder.com/images/20180701/305473_1530452990874_8C754812CCEC7267CC44FF197D74283A)

AC代码：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int N = 1e6+100;
const int mod = 1e9+7;
const int INF = 0x3f3f3f3f;
int fa[N];
int find(int x){
	return fa[x] == x ? x : fa[x] = find(fa[x]);
}
void merge(int x, int y){//合并，把是同类的合并在一起
	fa[find(x)] = find(fa[y]);
	return ;
}

void solve(){
	int n,k;
	cin >> n >> k;
	for(int i = 0; i < 3*n; i++){
		fa[i] = i;
	}
	int d,x,y,cnt = 0;
	for(int i = 0; i < k; i++){
		cin >> d >> x >> y;
		if(x > n || y > n){
			cnt++;
			continue;
		}
		if(d == 1){
			if(find(x)==find(y+n) || find(x)==find(y + 2*n)){
				cnt++;
			}
			else{
				merge(x,y);
				merge(x+n,y+n);
				merge(x+2*n,y+2*n);
			}
		}
		if(d == 2){
			if(find(x)==find(y) || find(x)==find(y + 2*n)){
				cnt++;
			}
			else{
				merge(x,y+n);//当不矛盾时，y被x吃于是y就是下一种物种。
				merge(x+n,y+2*n);//若有n个物种也按照这样的顺序，则写一个for循环
				merge(x+2*n,y);//merge(x+i,y+i+1);
			}
		}
	}
	cout << cnt << endl;
	return ;
}

signed main(void){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	int t = 1;
	//cin >> t;
	while(t--){
		solve();
	}
	return 0;
}
```



### 搜索

常用的搜索方法：

![image-20231126184736163](https://cdn.jsdelivr.net/gh/Zeratuli/Image@main/img/202401191809362.png)

#### DFS深度优先搜索

（Depth-First Search）深度优先搜索是一种搜索策略，通过每次找能搜的最远的路来进行搜索

例题：求全排列。

代码：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int N = 1e3+100;
const int mod = 1e9+7;
const int INF = 0x3f3f3f3f;

int n;
int a[N];
int vis[N];
void dfs(int dep){//dfs的核心，分为输出与修改两个板块
	if(dep > n){
		for(int i = 1; i <= n; i++){//将变好的节点输出
			 cout << a[i] << " ";
		}
		cout << endl;
		return ;
	}
	for(int i = 1; i <= n; i++){//变节点
		if(vis[i]) continue;
		a[dep] = i;
		vis[i] = 1;//只要访问过，就把这个点的vis改为1，在上面的if直接消耗掉
		dfs(dep+1);
		a[dep] = 0;
		vis[i] = 0;//重新把i的点访问情况重置，便于下次访问
	}
}

void solve(){
	cin >> n;//层数
	dfs(1);//这里决定了初始的dfs从哪里开始，即根从几开始
	return ;
}

signed main(void){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int t = 1;
	while(t--){
		solve();
	}
	return 0;
}
```

n皇后问题：假设有n*n的场地，每行有且仅有一个皇后，每列也只能有一个皇后，每斜线也只能有一个皇后，问有多少种摆法？

主要是一道路径搜索问题，按照顺序逐次向下搜索，每次若符合条件则将那个点改为走过，若不成立则回退到上一个点，通过dfs可以解决这道问题。

时间复杂度是一个固定值：$$O(n!)$$

代码：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int N = 1e6+100;
const int mod = 1e9+7;
const int INF = 0x3f3f3f3f;

int n,cnt = 0;
int a[N],column[N],diagonal[N],back_diagonal[N];

void show(void){//这里用于展示最终结果
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= n; j++){
			if(a[i] == j) cout << "+";
			else cout << "O";
		}
		cout << endl;
	}
	cout << endl;
	return ;
}

void dfs(int dep){
	if(dep > n){
		show();
		cnt++;//这里可以解决计数问题
		return ;
	}
	else{
		for(int i = 1; i <= n; i++){
			if(column[i] == 0 && diagonal[dep-i+n] == 0 && back_diagonal[dep+i] == 0){//这里限制了每个地方只出现一次皇后
				a[dep] = i;
				column[i] = 1;
				diagonal[dep-i+n] = 1;
				back_diagonal[dep+i] = 1; 
				dfs(dep+1);
				column[i] = 0;
				diagonal[dep-i+n] = 0;
				back_diagonal[dep+i] = 0; 
			}
		}
	}
}

void solve(){
	cin >> n;
	dfs(1);//这里传入的是层数
	return ;
}

signed main(void){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int t = 1;
	//cin >> t;
	while(t--){
		solve();
		cout << cnt << endl;
	}
	return 0;
}
```

效果：
![image-20231127222858337](https://cdn.jsdelivr.net/gh/Zeratuli/Image@main/img/202401191809363.png)

##### DFS解决迷宫类问题

迷宫类问题，就是有一个出发点与目的地，然后看能否从出发点出发到达目的地的一类题型。思路就是根据每步行走的方式制定一个(direct)指导，每次按照指导和限制条件来走即可。

由于不知道每次for循环进行continue的次数，因此不好计算时间复杂度是多少，最大的时间复杂度为$$O({行走方式数}^{格子数})$$，下面这题就是$$O({4}^{m*n})$$

例题：

AC代码

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int N = 5e3+10;

int m,n,sx,sy,cnt = 0;
char a[N][N];//地图
int vis[N][N];//访问节点
int dir[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};//{路径行走方式}

int dfs(int x, int y){
    if(a[x][y] == 'E'){//找到终点结束方式
        return 1;
    }
    vis[x][y] = 1;
    for(int i = 0; i < 4; i++){
        int dx = x + dir[i][0];//按照行走方式进行路径规划
        int dy = y + dir[i][1];
        if(dx <= 0 || dx > n || a[dx][dy] == '#' || dy <= 0 || dy > m || vis[dx][dy] != 0) continue;
        if(dfs(dx,dy)) return 1;//找到就返回1，提早结束避免复杂度过大
    }
    return 0;
}

void solve(){
    while(cin >> n >> m){
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m ; j++){
                cin >> a[i][j];
                vis[i][j] = 0;
                if(a[i][j] == 'S'){//找到起始点，一会从起始点出发
                    sx = i;
                    sy = j;
                }
            }
        }
        vis[sx][sy] = 1;//将起始点设为走过
        if(dfs(sx,sy)) cout << "Yes" << endl;
        else cout << "No" << endl;
    }
    return ;
}

signed main(void){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t = 1;
    //cin >> t;
    while(t--){
        solve();
    }

    return 0;
}
```

##### 用DFS解决数独问题

数独问题是一类很常见的数学趣味问题以填满整个格子为标准。

如题：

[1010-数独挑战_2021秋季算法入门班第六章习题：搜索与搜索剪枝 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/23156/1010)

输入

```
5 3 0 0 7 0 0 0 0
6 0 0 1 9 5 0 0 0
0 9 8 0 0 0 0 6 0
8 0 0 0 6 0 0 0 3
4 0 0 8 0 3 0 0 1
7 0 0 0 2 0 0 0 6
0 6 0 0 0 0 2 8 0
0 0 0 4 1 9 0 0 5
0 0 0 0 8 0 0 7 9
```

输出

```
5 3 4 6 7 8 9 1 2
6 7 2 1 9 5 3 4 8
1 9 8 3 4 2 5 6 7
8 5 9 7 6 1 4 2 3
4 2 6 8 5 3 7 9 1
7 1 3 9 2 4 8 5 6
9 6 1 5 3 7 2 8 4
2 8 7 4 1 9 6 3 5
3 4 5 2 8 6 1 7 9
```

AC代码：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long

int n = 9;
int a[12][12];
int row[12][12], column[12][12], vis[12][12];//分别代表行是否用过，列是否用过，小方块内是否被用过
const int subcube[10][10] = {
	{0,0,0,0,0,0,0,0,0,0},
	{0,1,1,1,2,2,2,3,3,3},
	{0,1,1,1,2,2,2,3,3,3},
	{0,1,1,1,2,2,2,3,3,3},
	{0,4,4,4,5,5,5,6,6,6},
	{0,4,4,4,5,5,5,6,6,6},
	{0,4,4,4,5,5,5,6,6,6},
	{0,7,7,7,8,8,8,9,9,9},
	{0,7,7,7,8,8,8,9,9,9},
	{0,7,7,7,8,8,8,9,9,9},
};//确认当前位置的值是第几个方块
struct coordiate{//0的坐标
	int x,y;
}vd[90];//代表这个地方是否为0，9*9=81所以开90
int cnt = 0;

void show(void){
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= n; j++){
			cout << a[i][j] << " ";
		}
		cout << endl;
	}
	cout << endl;
	return ;
}

void dfs(int dep){
	if(dep > cnt){
		show();
		return ;
	}
	int x = vd[dep].x;//找到为0的坐标
	int y = vd[dep].y;
	for(int i = 1; i <= n; i++){
		if(row[x][i] == 0 && column[y][i] == 0 && vis[subcube[x][y]][i] == 0){//vis：第几个小方块的第几个数
			a[x][y] = i;//修改数独的值

			row[x][i] = 1;
			column[y][i] = 1;
			vis[subcube[x][y]][i] = 1;
			dfs(dep+1);//正确就继续
			row[x][i] = 0;
			column[y][i] = 0;
			vis[subcube[x][y]][i] = 0;
		}
	}
	return ;
}

void solve(){
	//cin >> n;
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= n; j++){
			cin >> a[i][j];
			if(a[i][j] == 0){
				vd[++cnt].x = i;//将是0的地方记录一下，在dfs时只对这些值进行修改
				vd[cnt].y = j;
			}
			else{
				row[i][a[i][j]] = 1;
				column[j][a[i][j]] = 1;
				vis[subcube[i][j]][a[i][j]] = 1;
			}
		}
	} 
	dfs(1);
	return ;
}

signed main(void){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	int t = 1;
	//cin >> t;
	while(t--){
		solve();
	}
	return 0;
}
```

如果希望对算法进行优化，可以选择把一行中数字多的先进行dfs，便于减少递归次数。

即增加三个记录：记录每行，每列，每个小方格的字母数量，把数量大的排前面。

```c++
int recordrow[10],recordcolumn[10],recordvis[10];
```

然后对vd进行sort排序即可。

#### BFS广度优先搜索

（Breadth-First Search）广度优先搜索与深度优先搜索一样，是一种搜索策略。通过不断细分每一个拐角路径进行搜索，同时将上一个用过的节点删除，以达到遍历整个图的目的。

因为广度优先搜索直接遍历整个地图，于是在遇见迷宫类问题时，采用广度优先搜索可以以更小的复杂度完成迷宫问题，通常按长宽m，n计算的话，BFS最大的时间复杂度为$$O(m*n)$$

例题：马的遍历(国际象棋)

让一只马从他所站的位置出发，走过整个地图，表明每一处走过路径的位置与次数。

代码：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int N = 1e6+100;
const int dir[8][2] = {{-1,2},{1,2},{2,1},{2,-1},{-1,-2},{1,-2},{-2,1},{-2,-1}};//指导
int a[10][10];
int dis[10][10];
int n,m;
queue<int> q;

bool inmap(int x, int y){
	return x >= 0 && y >= 0 && x < n && y < m;//限制条件
}

void bfs(int x, int y){
	memset(dis,-1,sizeof(dis));
	dis[x][y] = 0;
	q.push(x*m+y);
	while(!q.empty()){
		int temp = q.front();
		int x = temp/m;
		int y = temp%m;
		q.pop();
		for(int i = 0; i < 8; i++){
			int dx = x + dir[i][0];
			int dy = y + dir[i][1];
			if(inmap(dx,dy) && a[dx][dy] == 1 && dis[dx][dy] == -1){
				dis[dx][dy] = dis[x][y] + 1;
				q.push(dx*m+dy);
			}
		}
	}
	return ;
}


void solve(){
	cin >> n >> m;
	for(int i  = 0 ; i < n; i++){
		for(int j = 0; j < m; j++){
			cin >> a[i][j];
		}
	}
	int mx,my;
	cin >> mx >> my;
	
	bfs(mx,my);
	for(int i = 0; i < n; i++){
		for(int j = 0; j < m; j++){
			//if(dis[i][j] == -1) cout << "#" << "\t";
			 cout << dis[i][j] << "\t";
		}
		cout << endl;
	}
	return ;
}

signed main(void){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	int t = 1;
	//cin >> t;
	while(t--){
		solve();
	}

	return 0;
}
```





#### 双向bfs



双向bfs是用于解决那些搜索过程繁杂而需要简化步骤的题，如果与字符串有关，需要用map去映射成不同的数字方便查找，并记录每个节点的大小，对能连接的节点采取相加策略，继而解决题目。

例题：

[1016-[NOIP2002]字串变换_2021秋季算法入门班第六章习题：搜索与搜索剪枝 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/23156/1016)

题目描述

已知有两个字串 A, B及一组字串变换的规则（至多6个规则）:

```c++
 A1 -> B1
 A2 -> B2
```

 规则的含义为：在A中的子串 A1可以变换为 B1、A2可以变换为 B2 …。
 例如：`A＝'abcd'　B＝'xyz'`
 变换规则为：
 `‘abc’->‘xu’　‘ud’->‘y’　‘y’->‘yz’`
 则此时，A可以经过一系列的变换变为B，其变换的过程为：
 `‘abcd’->‘xud’->‘xy’->‘xyz’`
 共进行了三次变换，使得A变换为B。

输入描述:

```
输入格式如下：
A B

A1 B1 \

A2 B2  |-> 变换规则

... ... / 

所有字符串长度的上限为 20。
```

输出描述:

```
输出格式如下：
若在10步（包含 10步）以内能将A变换为B，则输出最少的变换步数；否则输出"NO ANSWER!"                    
```

示例

输入

```
abcd xyz
abc xu
ud y
y yz
```

输出

```
3
```

这道题就是典型的运用双向bfs进行解题的方法，单向bfs需要的层数太多状态太复杂，因此可以利用双向bfs进行优化，当然也可以运用迭代加深算法求解。

用mp1，mp2分别记录进行搜索的字符串的内容，若能在mp2中搜索到

AC代码：

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6+10;
int cnt = 0, step[N], n = 0;
map<string,int> mp1,mp2;
string A,B,a[10],b[10];
queue<string> q1,q2;

void tran(int rec,string &cur,int i,string a[],string b[]){
	cur.erase(rec,a[i].length());
	cur.insert(rec,b[i]);
}

int calculate(map<string,int> &mp1, map<string,int> &mp2, queue<string> &q, string a[], string b[]){
	int size = q.size();//q.size()如果放在循环中每次都会计算大小，会有开销
	for(int f = 0; f < size; f++){//这一步循环是为了获得q中已有的元素，然后把已有元素拿出来用一遍
		string temp = q.front();
		q.pop();
		for(int i = 0; i < temp.size(); i++){//这里与bfs的while等同
			for(int j = 0; j < n ; j++){
				int rec = temp.find(a[j],i);
				if(rec != temp.npos){
					string cur = temp;	
					tran(rec,cur,j,a,b);
					if(mp2.find(cur) != mp2.end()){
						return step[mp1[temp]] + step[mp2[cur]] + 1;
					}
					if(mp1.find(cur) == mp1.end()){
						mp1[cur] = ++cnt;
						step[cnt] = step[mp1[temp]] + 1;
						q.push(cur);
					}
				}
			}
		}
	}
	return -1;
}

int bfs(){
	q1.push(A);q2.push(B);
	mp1[A] = ++cnt;mp2[B] = ++cnt;
	while(q1.size() && q2.size()){
		int x = -1;
		if(q1.size() <= q2.size())
			x = calculate(mp1,mp2,q1,a,b);
		else
			x = calculate(mp2,mp1,q2,b,a);
		if(x!=-1&&x<10) return x;
	}
	return -1;
}

void solve(){
	cin >> A  >> B;
	while(cin >> a[n] >> b[n]) n++;
	int ans = bfs();
	if(ans == -1) cout << "NO ANSWER!" << endl;
	else cout << ans << endl;
	return ;
}

signed main(void){
	ios::sync_with_stdio(false);
	cin.tie(0);

	int t = 1;
	//cin >> t;
	while(t--){
		solve();
	}

	return 0;
}
```



### 对拍

需要四份文件：

1.baoli.cpp 暴力保证答案正确的cpp文件

2.std.cpp 未知是否能通过，但复杂度比暴力小的文件

3.data.cpp 能生成随机数的data文件(可根据需要自动修改)

4.duipai.cpp 对拍程序

1，2程序是题目内容

3.如下：

```C++
#include<bits/stdc++.h>
#define ll long long

ll Random(ll mod)
{
    ll ans = 2147483647;
    return ans = ans * rand() % mod + 1;
}

int main()
{
    struct _timeb T;
    _ftime(&T);
    srand(T.millitm);
    
    ll n;
    int t = 100000;
    int j = 10000;
    while(t--){
        int k = j;
        printf("%d\n",j++);
        while (k--);
        {
            n = Random(1000);//1000为上限
            printf("%lld ", n);
        }
    }
    return 0;
}

```

4.如下：

```C++
#include <iostream>
#include <cstdio>
#include <windows.h>
#include <cstdlib>
#include <ctime>
using namespace std;
int main()
{
    int ok = 0;
    int n = 50;
    for (int i = 1; i <= n; ++i)
    {
        system("data.exe > in.txt");
        system("std.exe < in.txt > std.txt");
        double begin = clock();
        system("baoli.exe < in.txt > baoli.txt");
        double end = clock();

        double t = (end - begin);
        if (system("fc std.txt baoli.txt"))
        {
            printf("测试点#%d Wrong Answer\n", i);
        }
        else if (t > 1000) //1秒
        {
            printf("测试点#%d Time Limited Exceeded 用时 %.0lfms\n", i, t);
        }
        else
        {
            printf("测试点#%d Accepted 用时%.0lfms\n", i, t);
            ok++; //AC数量+1
        }
    }
    printf("\n");
    double res = 100.0 * ok / n;
    printf("共 %d 组测试数据，AC数据 %d 组。 得分%.1lf。", n, ok, res);
    system("pause");
}

```

50组数据的对拍程序



